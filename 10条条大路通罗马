All Roads Lead To Rome 
之前关注点是罗马,因为它繁华.后来关注点是路.因为它抽象,它有了新的意义.它暗指方法.
这句话也就成了"一个问题有多个解"通俗的说法.
在Julia里面,我们用Method表达"一个问题有多个解"这件事.当然,编程里面有个术语,叫多态.也是在说这件事.
比较简单易理解多态的例子是这样的.
sort ,也就是排序.多态大概有两种,一种是基于参数,另一种是基于实现.
基于参数的多态是这样的,比如给数字排序,给字符串排序. 传入的参数类型不一样,就需要有不一样的答案.
Julia里面method,用来表达基于参数的多态很合适.
举个例子:
f(x::Float64, y::Float64) = 2x + y
julia> f(2.0, 3.0)
7.0
f(x::Number, y::Number) = 2x - y;
julia> f(2.0, 3)
1.0
f()="Hello World"
julia> f()
"hello world"

julia> methods(f)
# 3 methods for generic function "f":
f() at REPL[9]:1
f(x::Float64, y::Float64) at REPL[8]:1
f(x::Number, y::Number) at REPL[10]:1

这就是基于参数的多态,函数名相同,参数不一样,然后调用的时候,会根据传参找到对应的实现,然后调用定义的函数.这是常见的函数式多态.

第二种多态,基于实现的多态.面向对象的多态,一个接口多个实现.比如,一个排序算法,参数都一样,都是数字,但是实现有区别,有快速排序法,有冒泡排序法,有希尔排序法等等.
好多种呢.怎么区别这些不同的实现?
这里得先简单了解一下Julia的类型系统.
类型依旧是容器或者说是载体,它是标准容器.可供参考.为啥可供参考,因为它有了额外的信息.最明显也最重要的是类型名.这就相当于,容器里一直有个键值对,{类型名:类型值}.它具有标识的作用.
在Julia里面声明个类型是这样的：type 帅哥 end
或者这样的: abstract  帅哥 
或者这样的： bitstype 32 我的哥
当然好玩的是这样的,
	type 小鲜肉
           帅哥
           年龄::Int
           资产::Float64
    end

解释一下, type 类型名 end 就声明了一个类型, 
type 小鲜肉
           帅哥
           年龄::Int
           资产::Float64
    end
	这种是声明一个组合类型.
	abstract 是抽象类型,bitstype 是位类型.
还有不可变的类型 
immutable 爱情
	He
	She
end
类型简单说一下,还有很多丰富的特性,比如参数化类型,类型别名等.我后面说,或者看这个文档吧.http://docs.julialang.org/en/stable/manual/types/#type-declarations

重要的是给类型加方法.
比如:
immutable Polynomial{R}
    coeffs::Vector{R}
end

function (p::Polynomial)(x)
    v = p.coeffs[end]
    for i = (length(p.coeffs)-1):-1:1
        v = v*x + p.coeffs[i]
    end
    return v
end
这代码套路很像Go语言的那套.
julia> p = Polynomial([1,10,100])
Polynomial{Int64}([1,10,100])

julia> p(3)
931
这样类型就可以当函数的使用了.
那酱紫,
immutable QuickSort end
immutable PopUpSort end

function (sort::QuickSort)(dataToSort) end
function (sort::PopUpSort)(dataToSort) end
这样就实现了基于实现的多态.
是不是比较绕?举止略显慌张,不够从容优雅? 先酱紫吧.

类型之间可以有关系,关系很简单,继承.用 <: 来表示.
比如 bitstype 16 Float16 <: AbstractFloat
这个还是可以理解的,牢记七字真言:界门纲目科属种.

类型其实是个很复杂的东西,不是在Julia里面使用或者定义复杂,而是它隐射的内容复杂,它这个涉及到分类学.
也就是分类这件事.我们做的大部分事情,其实都可以理解为分类. 目前比较火的机器学习,人工智能等,一部分问题可以从分类的角度去理解并解决.有些场景,解决的还是蛮好的.
分类涉及分类原理分类方法.分完的类又涉及类的相互关系,联系与区别.也是蛮复杂的.
说说分类方法吧.搬一些名词先,统计决策方法之贝叶斯决策. 线性分类器之Fisher线性判别,感知器,最小平方误差判别.
非线性分类器之分段线性函数,二次判别函数,多层感知神经网络,支持向量机,核函数机器.其他分类法之近邻法,决策树与随机森林法,罗杰斯特回归,Boosting方法.
不要问我这堆名词是啥意思,我也不知道.人丑就要多读书,这些是科学,懂吗? 不懂还不赶紧去学习..
总之,你有一个标准,然后,按满足条件的是一类,不满足条件的是另一类.这个标准可以随意建立,但是有意义的标准不好建立.
因为这个标准的建立,其实是我们对事物的认识.知之还是蛮难的.
分类完了后,还有一个检验的过程,叫评价或者判别.意思是一样的,正如张五常在玉石市场研究里说的:没有专家鉴定，玉石一文不值.为啥呢?因为评价后的东西才有价值.
所以,评价体系和判别函数很重要哦.这对我们个人也是有启发作用的.不要在乎别人的意见.但是,总有个人对你的评价,你得在乎.写代码也是一样的,写完的代码得进行测试.
不测试,写的不是代码,是Bug. 

关于罗马大道,就传这么多教啦.
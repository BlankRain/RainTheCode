君子爱财,取之有道
我虽然还是个穷小子,也来说说赚钱的事情.钱与女人,噢,不对,不对,事业与爱情,永恒的话题.谁都可以说,谁都说不对,或者谁说都是对的.
先说如何赚钱?低买高卖! 就这么简单,低价进高价出.高减低的就是你赚的.是不是很有道理?大家一时间都无言以对.
这里有几个忠告,不要高买低卖，不要买了不卖.这两个道理很简单朴素.但是并不代表这两个错误你不会犯.请铭记于心.好多企业倒闭,无非就是犯了这两错.
再这样玩,全村人民要号啕了.各位看官,稍安勿躁.我这还有一个小秘密.关于长寿的秘诀哦,长寿的秘诀是啥?保持呼吸,不要断气.一般人我不告诉他.
哈哈哈~年纪轻轻我就悟出了如此哲理,前途无量啊.
言归正传.
很显然,问题并不在于如何赚钱.大家关心的是如何赚大钱,如何快速赚钱,如何长久持续的又好又快的赚大钱.
作为一名开花攻城狮,我很诚恳的先告诉大家一个小道理:做好一件事的基本条件是做完一件事.
这是我在南京明故宫一位姓朱的叔叔告诉我的.他经常夜里在明故宫门洞里面唱歌.
我去那里听过.他说:"唱一首完整的歌".所以,长久持续的又好又快的赚大钱的前提是先赚钱.后面,我不提赚钱了.
因为赚钱只是我们日常生活中的一件事.一件比较重要且关注程度高的事情.既然是做一件事,基本方法有了.
第二个问题就是,在这个基础上,如何又好又快的做好一件事?这是一个相对比较具体,也更值得仔细讨论的问题.
会了这个,你就可以长久持续的又好又快的赚大钱,你也可以长久持续的又好又快的秀恩爱. 从此爱情事业双丰收.

来来来,再来看一眼我们的问题,已知做事的方法,如何又好又快的做好一件事? 再换个说法,已知做事的方法，如何高效行动?
是啊,已知做事方法,如何高效行动呢? 答案就是. 其实我也不知道. 我爱情事业都还空着呢.但是,好的问题,总会引发思考.有意识的思考,虽然没有正确答案.
但是有错误答案啊.很多时候知道正确的并不重要,知道什么是错的,比知道正确的要重要.想学好先学坏.具体答案各位自己想去吧.
我心里有些自己的谱.但是我不会告诉你们.原因无他,说了你们不会信.不信就不会去实践,不实践就不会有效果,没有效果就更不会信.
成功死循环.所以,我不说.虽然我不说,但不代表着你不能得到答案.
下面,我要说一个东西,与高效行动有关.代码方面的,叫元编程(meta-programming).
meta-programming（a.k.a.元编程）中的这个meta-词前缀源自希腊词，本意为“在…后，变换，以上”。
经过几千年的演进，这个词前缀有了一种全新的意义：关于事物自身的事物。
比如 meta-knowledge 就是“关于知识本身的知识”，
	meta-data 就是“关于数据的数据”，
	meta-language 就是“关于语言的语言”，
	而 meta-programming 也是由此而来，是“关于编程的编程”。

元编程
元编程算不上什么新鲜的概念，各种语言里早已有之：

C和Lisp系语言里的宏
C++里的模板
Java的注解
C#的属性和反射
各种脚本语言（如javascript、python）的eval
……
Matz 给元编程的定义是：

编写能在运行时操作语言构件的代码

So，元编程是“让代码写代码”，是“运行时操作语言”.
天下文章一大抄,我又毫不羞耻的引经据典了.没办法,我是靠脸吃饭的,别人靠颜值,我靠厚度.
这次抄的是全炸大神龙三的文章.原文看这里 http://www.moye.me/2016/10/15/ramble_on_meta-programming/.
那么问题来了,这跟高效行动有啥关系?跟赚钱有啥关系? 哦~ 对不起,请原谅.没有直接关系. 注意,是直接. 间接关系是有的."让代码写代码",其实就是一种高效行动.
这个概念很容易推广啊.比如,让钱赚钱嘛.让爱情来谈情说爱嘛.思路是不是开阔了?可能会依旧懵逼.让钱赚钱很容易理解,放贷啊.看看银行,看看财团.不都干这行么.
让爱情来谈情说爱.这个就不好理解了.不过也没有那么难.王小波写了一篇关于爱情的小说<<绿毛水怪>>,李银河看了,冥冥之中感觉要和这个自由浪漫的丑男人发生点什么.
后来,他爱了她一辈子,她爱了他一生.

Julia里面的元编程,用的是宏.抄袭,不对,是借鉴.读书人的事情,怎么能说抄袭呢?借鉴了LISP里面的概念.
既然是这样,那就先说说LISP里面的宏.不能数典忘祖,一楼先祭我LISP老祖.
LISP老祖有好几个分身,就跟大师有好几个徒弟一样,各个都觉得自己得了真传.我信的是JVM系的Clojure派.JVM是Java 虚拟机的意思,Clojure是一门跑在JVM上的LISP分身.
Clojure，我一般念"抠脚". 关于我的形象,是不是一下具体起来了? 凌乱的桌面,散乱的头发,专注的眼神,噼里啪啦的键盘,老坛酸菜泡面,已然溢出的烟灰缸,
摔倒的啤酒瓶子,半只拖鞋,丢弃的卫生纸,啃剩下的鸡骨头,以及半包已开封的辣条.印着HelloWorld的咖啡杯. 
所有的一切都在告诉这个世界,这是一个屌丝青年.哈哈哈...
编程语言是一种构建抽象的方式. 抽象是啥? 说抽象必须得说说具体. 一般概念是抽象的.符合概念的实体是具体的.
举个例子,帅哥,是个概念.它是抽象的.王力宏,孙红雷还有我,是个人,是帅哥,是具体的. 这个不难理解哦.这个是简单级别的抽象.复杂级别的抽象是逻辑上的抽象,关于抽象的抽象.
哈哈,懵逼了吧.来来来,给你们断句."关于抽象的抽象"这句话里,第一个抽象是名词,第二个抽象是动词.这下明白了吧?名词的抽象,是指对某一事物进行抽象操作后的产物. 
动词的抽象,是指生产名词性的抽象的动作或过程. 不多说了,觉得绕的,慢慢绕吧.

宏呢,就是提供一种逻辑上的抽象. Clojure的宏,提供的是一种高效的逻辑上的抽象. 区别点在高效.本质在逻辑上的抽象.
这个得举个例子,顺带黑黑我大Java.
在Java里面 for循环 早期版本是这样写的.
 for(int i=0;i< collection.size();i++){
	doSomethingBadWith(collection.get(i));
 }
这是一个逻辑上的抽象,抽象的是遍历一个集合并干点坏事情的过程.
doSomethingBadWith 是个方法,干点小坏事. 这个不是重点. 重点在 for (int i=0....) 和 collection.get(i) 这里.它访问元素用的是下标.下标粗心的话容易算错.
算错就是个 IndexOutOfBoundException 或者 NullPointerException, 这两玩意是异常,你懂不懂都没关系.有关系的是,丢出来的异常,扔的你一愣一愣的.
那么就出来个改进型的写法,安全简单好写.
for(SomeType element: collection){
	doSomethingBadWith(element)
}
这种写法没有下标,不会出现对方并不想跟你说话,并向你丢了个IndexOutOfBoundException 异常这种情况.
没宏,Java程序员忍了8年,才等到改进型的for循环.
有宏的话,Clojure里面是这样写的,别晕菜,看不懂没关系.
( defmacro foreach [[sym coll] &body]
	`(loop [coll# `coll]
	(when-let [[`sym & xs#] (seq coll#)]
		~@body
	(recur xs#))))
上面的代码,其实我也懵逼. 哈哈哈,以我昏昏,使汝昭昭.

代码不是重点,重点是你有一种方式,可以自己改进或者构造语法.
单单从抽象上来说,宏和函数其实是一样的.但宏跟函数的根本区别在于,宏是运行在编译期的,函数运行在运行期.
它们的运行环境不同,所以呢,表现出来的能力就不一样了. 啥是编译期,运行期?
源码一般都是文本的,要被编译器读进来,编译成二进制文件.这个过程叫编译期.编译后的二进制文件被运行环境执行.这个运行环境可能是操作系统或者JVM.
执行的这个过程,就是运行期.所以啊,夏虫不可语冰.运行期里面不提宏.编译期里面函数不执行,不要抬杠,执行的是宏.
非要抬杠,那我认输.我已经认输了,你干嘛还打我脸? 哈哈哈...

能跟编译器交互,也就是可以在编译期进行逻辑上的抽象,这个好多语言都有,不是卖点. 上面说了,区别点在高效.
如何高效了? LISP的代码有个特点叫同像性.啥是同像性? 最大的直觉是括号括号括号.比如 （+ 1 2 3） （+ （- 2 3）1）
这种括号形式叫S表达式,高大上的名字,其实就一点(操作符 参数一 参数二 参数三...),很简单的约定. () 是列表的意思.LISP里的L.
孙子十三篇之兵势篇里面曰了个这么一段:
凡战者，以正合，以奇胜。故善出奇者，无穷如天地，不竭如江海。终而复始，日月是也。死而更生，四时是也。
声不过五，五声之变，不可胜听也；色不过五，五色之变，不可胜观也；味不过五，五味之变，不可胜尝也；战势不过奇正，奇正之变，不可胜穷也。
奇正相生，如循环之无端，孰能穷之哉！
天下文章一大抄,又抄了一大段文章.看最后一句,"奇正相生，如循环之无端，孰能穷之哉！".这S表达式里面嵌套S表达式,如循环之无端，孰能穷之哉. 这性质也叫自相似.

好了,博古通今之后,说重点.
在Julia里面,每个程序开启它的人生之旅于一个字符串. 也就是源文件嘛,都是文本的。
文本的源文件,会被解析.怎么解析的? Julia有个parse函数,快抓住它,就是这个函数干的.
来举个例子看看
myLife="println(\"wow,awesome life\")"
whatMyLifeIs=parse(myLife)
执行是这样的:
julia> myLife="println(\"wow,awesome life\")"
"println(\"wow,awesome life\")"

julia> whatMyLifeIs=parse(myLife)
:(println("wow,awesome life"))

help?> whatMyLifeIs
search:
  No documentation found.
  whatMyLifeIs is of type Expr.
  Summary:
  type Expr <: Any
  Fields:
  head :: Symbol
  args :: Array{Any,1}
  typ  :: Any
解析后是个表达式对象,这玩意是这样的:(println("wow,awesome life")) ,其实就是LISP里面的S表达式.
官方文档加黑加粗这么说的:
The key point here is that Julia code is internally represented as a data structure that is accessible from the language itself.
啥意思? 无它,数据即代码耳.借鉴的LISP么.所以,Julia的元编程,其实就是个构造表达式对象的过程.
自己手动构造表达式对象,然后eval,还是复杂抽象了点. 可以看http://docs.julialang.org/en/stable/manual/metaprogramming/ 里的例子.
说好的高效呢? 于是乎,出现了 macro .
比如定义一个宏:
macro sayhello(name)
           return :( println("Hello, ", $name) )
end
:() 是构造表达式对象的意思.大名叫语法糖,啥意思?理解成简写就好.它是干啥的? 就当是专业生成表达式对象的吧.
定义宏用的是 macro 关键字.感觉和函数差不多对吧. 区别是函数是function关键字.
上面说了,Julia元编程是生成表达式嘛.所以,return 的对象都是表达式了.当然,你也可以试试return 其他东西看看.

这里再抄个例子,说的是编译期和运行期的事情.
julia> macro twostep(arg)
           println("I execute at parse time. The argument is: ", arg)
			#这里我可以对参数做些坏事情. 比如加一个,少一个,或者改一个.还不是任你玩.哈哈..
           return :(println("I execute at runtime. The argument is: ", $arg))
       end

julia> ex = macroexpand( :(@twostep :(1, 2, 3)) );
I execute at parse time. The argument is: :((1,2,3))

macroexpand是宏展开函数,相当于编译.

Julia里面宏调用和函数调用有点区别, 函数调用是 someone() 宏调用是 @someone(),其他的一样.

宏有好多高级玩法哦,比如生成代码啥的.总之,强力的脚手架.
参考资料看这个,http://docs.julialang.org/en/stable/manual/metaprogramming/

最后再说说@someone,这种语法格式@something,Java里面是注解.Python里面也是注解.
比如 Python :
def Jack(she):
    print("I Jump")
    return she

@Jack
def Lucy():
    print("You Jump")
    return "The End"

Lucy()
结果是这样的：
>>> 
I Jump
You Jump
>>> 
@Jack是个注解调用

Julia 里面可以这样玩哦.
 macro Jack(she)
	print("I Jump\n")
	return she
 end
 function Lucy()
	print("You Jump\n")
	"The End"
 end
 
 julia>  @Jack(Lucy)()
  I Jump
You Jump
"The End"
结果是个这,还是蛮方便的.上面代码没看懂没关系,不影响重点.
Python 的这个注解特性支持也是新版本才支持的.而自己用宏的话,就可以自己写了嘛.理论上,你可以做任何事. 
宏在手,则编译器在手.编译器在手,天下你有.

最后,再回到最初开始的地方. 君子爱财,取之有道.就跟代码有编译期,运行期一样.取财也有筹备期,执行期.
要在筹备期抽象出来一些执行逻辑.比如,企业的标准化.在真正上市场上买卖之前,企业内部按标准按流程先走一把.这类似于宏在编译期进行代码检查.
或者,像苏宁当年开店,每到一个地方,有个统一的开店手册.这就类似于宏的代码生成.总之呢.可以类比嘛. 
我们写的每行代码,都是对这个世界的理解.
最后,很重要的一件事,发财这种事,有的话记得喊我啊.哈哈哈~
关于把事情干漂亮,一言半语说不清,后面还会介绍.当然是从编程角度讲的.然后,自己类比.
孔夫子说了嘛,举一隅不以三隅反,则不复也. 举一反三,你就可以干漂亮很多事了.
关于举一反三,我得来段单口相声.
linux 有个著名的病毒,叫forkbomb.
就一行,这么写的 :(){ :|: & };:
:() 还有 :|: ,这玩意是不是看起来好萌.像字符表情.
但是这一整句,呆萌的面孔下,强劲的力量.它可以把你系统搞挂.搞挂的专业术语叫DOS,Denial of Service的缩写,
翻译过来叫拒绝服务攻击,意思就是搞挂.搞是搞挂的搞，挂是搞挂的挂.
详细解析一下:
:()  ：在这里是一个函数名，我们定义之，并在后面执行它
：|：& ：函数的输出通过管道传给另一个冒号函数作为输入，并且在后台执行
{ };标识着里面的内容是一个函数主体
最后一个：为定义完成后的一次函数执行。
首先需要说明的是:是一个shell内置命令，所以上面这段代码只有在bash中才可能产生fork炸弹，因为在其他一些shell中，内置命令的优先级高于函数，
所以执行:，总是执行内置命令。（：是一个空命令，while true等同于 while ：，常用作占位符） 
先来看看函数的主体：|：&，使用管道的时候是两个进程同时开始执行。
所以当执行一个：函数时，产生两个新进程，然后一个原来的进程退出，这样不停地递归下去，就产生了一个无限递归。按照这个增长模式的化，其增长趋势约为2n。

绕吗? 如果绕,就忽略. 一句话,这个forkbomb是个举一反二的故事.它每执行一下自己,会产生两个自己.就跟细胞分裂一样.一次分裂两,再继续分裂。操作系统哪扛得住这么分裂,
最后系统资源被耗尽了.然后就被搞挂了.这是一个 y=2^n 的相声.
那举一反三,其实就是个 y=3^n的相声,这个相声大家自己讲吧.

最后,总结一下:
正如胖松说的,牛逼的人到哪都是牛逼的.
何也?无他,举一反三,融会贯通.

嗯,大道一也.
